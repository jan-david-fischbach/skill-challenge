[
  {
    "objectID": "singlemode.html",
    "href": "singlemode.html",
    "title": "Single Mode",
    "section": "",
    "text": "The question is concerned with the single mode cutoff of a silicon nitride waveguide: &gt; What’s the maximum waveguide width for a silicon nitride at 1550nm TE polarization for 400nm thick to be single mode?\nTo answer that question lets sweep the effective index of the first couple of modes at different waveguide widths:\nstrip = gt.modes.Waveguide(\n    wavelength=1.55,\n    core_width=1.0,\n    slab_thickness=0.0,\n    core_material=\"sin\",\n    clad_material=\"sio2\",\n    core_thickness=400 * nm,\n    num_modes=4,\n)\n\nlight_line = 1.44\nw = np.linspace(200 * nm, 1100 * nm, 10)\n\nn_eff = gt.modes.sweep_n_eff(strip, core_width=w)\nte_pol = gt.modes._sweep(strip, \"TE_pol_fraction\", core_width=w)\n\n\n\n\n[05:31:26] WARNING: Mode field at frequency index 0, mode index 1 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 2 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 3 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n[05:31:28] WARNING: Mode field at frequency index 0, mode index 2 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 3 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n[05:31:30] WARNING: Mode field at frequency index 0, mode index 2 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 3 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n[05:31:33] WARNING: Mode field at frequency index 0, mode index 2 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 3 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n[05:31:35] WARNING: Mode field at frequency index 0, mode index 2 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 3 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n[05:31:38] WARNING: Mode field at frequency index 0, mode index 2 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 3 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n[05:31:41] WARNING: Mode field at frequency index 0, mode index 2 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 3 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n[05:31:46] WARNING: Mode field at frequency index 0, mode index 2 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 3 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n[05:31:51] WARNING: Mode field at frequency index 0, mode index 2 does not decay at the plane    mode_solver.py:428\n           boundaries.                                                                                             \n\n\n\n           WARNING: Mode field at frequency index 0, mode index 3 does not decay at the plane    mode_solver.py:428\n           boundaries.\nAnd also plot the results:\nplt.figure(figsize=(6,3))\n\nfor i in range(4):\n    y = np.array(n_eff.sel(mode_index=i).real)\n    plt.plot(w, y, color=\"gray\")\n    y[y&lt;light_line] = np.nan #do not consider polarization below the light line\n    plt.scatter(w, y, c = te_pol.sel(mode_index=i), cmap=\"jet\", vmin=0, vmax=1, label=f\"{i}\")\n    \ncbar = plt.colorbar(ticks=[0, 1])\ncbar.ax.set_yticklabels(['TM', 'TE'])\n\nplt.grid()\nplt.xlabel(\"Waveguide width [$\\mu$m]\")\nplt.ylabel(\"Effective Index\")\nplt.axhline(y=light_line, color=\"k\")\nplt.title(\"Effective index sweep\")\n\n\n\n\n:"
  },
  {
    "objectID": "singlemode.html#interpretation",
    "href": "singlemode.html#interpretation",
    "title": "Single Mode",
    "section": "Interpretation",
    "text": "Interpretation\nTwo modes are guided for small widths (quasi TE and TM), and a third mode crosses the light line (refractive index of the background material) at a width of ca. 0.9um. This is the point below which the given silicon nitride waveguide becomes single mode in the conventional sense. It only supports a single mode of the qTE polarization of interest. A stricter definition of single mode exists in literature: &gt; A single-polarization single-mode (SPSM) waveguide is a waveguide that is truly single-mode in the sense of supporting only a single guided-mode solution (rather than two or more, commonly corresponding to two polarizations as in standard “single-mode” fibers) - Lee et. al “Design strategies and rigorous conditions for single-polarization single-mode waveguides”\nThis condition cannot be met using rectangular silicon nitride waveguides (see mentioned paper). Therefore I assume the question targeted the single mode regime in the conventional sense."
  },
  {
    "objectID": "singlemode.html#notes",
    "href": "singlemode.html#notes",
    "title": "Single Mode",
    "section": "Notes",
    "text": "Notes\nAlso note that the qTE and qTM modes cross (having a degeneracy in w=400nm). This degeneracy exists, as I am using a drastically simplified model of a perfectly rectangular waveguide (no sidewall angle) without BOX etc. To get more accurate results the simulated material properties should also be calibrated to the intended foundary process. This statement is valid for all questions and will not be repeated going forward.\nTo color the modes according to their polarization I have monkey patched a property to determine the TE polarization fraction (Lumericals formula). I will create a PR later."
  },
  {
    "objectID": "eulerbend.html",
    "href": "eulerbend.html",
    "title": "Euler Bend",
    "section": "",
    "text": "The question states: &gt; What’s the minimum bend radius for an euler bend for 400nm thick silicon for 1um wide waveguides at 1550nm for TE polarization. What’s the optimal radius and p parameter?\nLet’s first get an intuition for the modes supported by a 400nmx1um silicon waveguide\nnum_modes = 12\nstrip = gt.modes.Waveguide(\n    wavelength=1.55,\n    core_width=1.0,\n    slab_thickness=0.0,\n    core_material=\"si\",\n    clad_material=\"sio2\",\n    core_thickness=400 * nm,\n    num_modes=num_modes,\n)\n\nlight_line = 1.44\n\nfig, axs = plt.subplots(num_modes//2, 2, figsize=(5, 1.5*num_modes//2))\nfor m, ax in enumerate(axs.flatten()):\n    strip.plot_field(\"Ex\", mode_index=m, ax=ax)\nprint(strip.n_eff)\n\n[3.11257216+7.32843736e-06j 2.92860407+2.48656630e-05j\n 2.82713474+1.55401589e-05j 2.69195954+3.11270123e-05j\n 2.29838515+4.27650747e-05j 2.28191374+4.23492723e-05j\n 2.18429146+4.41482052e-05j 1.72940619+9.42212267e-05j\n 1.65737157+7.71399957e-05j 1.64125925+1.71944180e-04j\n 1.46231259+2.17033188e-04j 1.43783098+2.13876809e-04j]\nNote that the given waveguide geometry supports 11 modes. 5 of which are qTE.\nTo me the question is somewhat unclear. Therefore I will try to amend the question in the way I belive it was intended:\nWhat’s the minimum bend radius for an euler bend for 400nm thick silicon for 1um wide waveguides at 1550nm for TE polarization, so that the fundamental mode has a transmission penalty of less then 0.01dB. What’s the optimal p parameter at a given effective radius to minimize that transmission penalty?"
  },
  {
    "objectID": "eulerbend.html#but-mode-mixing-losses",
    "href": "eulerbend.html#but-mode-mixing-losses",
    "title": "Euler Bend",
    "section": "But: Mode Mixing losses",
    "text": "But: Mode Mixing losses\nThe waveguide at hand is highly multimode. The loss of the fundamental mode will thus be dominated by coupling to higher order modes instead of radiative loss as it is the case for single mode waveguides. Thus we need a different simulation approach. FDTD/FDFD is computationally to expensive for the large simulatio volumes we require here. Thus I opt to use eigenmode expansion (eme) in a similar fashion as was used in the paper Analysis of silicon nitride partial Euler waveguide bends. To realize that I will be using the opensource eme framework meow. To capture the bend geometry a straight structure was used and the eme-cells were augmented with the bend radius at the corresponding position.\nTo speed up the simulation time of successive sweep points the modes were cached. The positions of the eme-cells was carefully chosen to maximize the mode reuse. A modified version of this script will be uploaded to the meow repo as an example. It is based on a prototype by Floris Laporte.\n\nfrom functools import lru_cache\n\nfrom scipy.special import fresnel\nfrom tqdm.notebook import tqdm\nfrom typing import Optional\n\neps = np.finfo(np.float64).resolution\n\n\n#@title Settings\nT = 38.0        #@param {type:\"number\"}  #Temperature in deg C\nwl_start = 1.5  #@param {type:\"number\"}  #Start wavelength in um\nwl_stop = 1.6   #@param {type:\"number\"}  #Stop wavelength in um\nnum_wl = 5      #@param {type:\"number\"}  #number of wavelengths\nw = 1           #@param {type:\"number\"}  #waveguide width in um\nt_slab = 0      #@param {type:\"number\"}  #slab thickness in um\nt_core = 0.400  #@param {type:\"number\"}  #core thickness in um\nt_ox = 3        #@param {type:\"number\"}  #cladding thickness in um; full extend\nnum_modes = 7   #@param {type:\"number\"}  #number of considered modes\nnum_cells = 35  #@param {type:\"number\"}  #number of cells in eme\nn_wg = 3.45     #@param {type:\"number\"}  #refractive index of the core\nn_ox = 1.46     #@param {type:\"number\"}  #refrective index of the cladding\nalpha_tot = np.pi/2 #angle of the full turn\nR_eff =  140     #@param {type:\"number\"}  #effective Radius in um\n\nR_eff_min = 130  #@param {type:\"number\"}  #minimum effective Radius in sweep\nR_eff_max = 400 #@param {type:\"number\"}  #maximum effective Radius in sweep\nR_eff_points = 10\nR_eff_sweep = np.logspace(\n    np.log10(R_eff_min), \n    np.log10(R_eff_max), \n    R_eff_points)\n\np = 0.5         #@param {type:\"number\"}  #part of the bend that is euler\np_sweep = np.logspace(np.log10(0.01), np.log10(0.25), 60)\n\nwl_mean = np.mean([wl_start, wl_stop])"
  },
  {
    "objectID": "eulerbend.html#euler-bend-intro",
    "href": "eulerbend.html#euler-bend-intro",
    "title": "Euler Bend",
    "section": "Euler Bend Intro",
    "text": "Euler Bend Intro\nAs we want to use scipy.special.fresnel to evaluate the fresnel integrals, we have to express the cos/sin argument as \\(\\frac{\\pi t^2}{2}\\) while it is \\(\\frac{t^2}{2R_0^2}\\) in the euler spiral. Thus let’s chose \\(R_0 = 1/\\sqrt{\\pi}\\)\n\ndef R_0() -&gt; float:\n  \"\"\"reference radius for use in fresnel integral\"\"\"\n  return 1/np.sqrt(np.pi)\n\nFrom the paper we know that we have to trace the path up to \\(s(\\alpha) = R_0\\sqrt{2\\alpha}\\) (eq. 3) thus to the end of the first euler section we find. Note: The angle at the end of the first euler part is \\(p\\alpha_{tot}/2\\)\n\ndef s_p(R_0:float, alpha_tot: float, p: float):\n  \"\"\"path length at interface between euler and circular bend\"\"\"\n  return R_0*np.sqrt(p*alpha_tot)\n\nThe radius of the circular section (unscaled) \\(R_p = \\frac{R_0}{2\\sqrt{p\\alpha/2}}\\) Note: this formula was found to not lead to the correct results. The corrected formula was taken from the gdsfactory euler bend implementation: \\[R_p = \\frac{R_0}{\\sqrt{p\\alpha}}\\]\n\ndef R_p(R_0:float, alpha_tot: float, p: float):\n  \"\"\"radius of the circular bend\"\"\"\n  return R_0/np.sqrt(p*alpha_tot)\n\nThe total bend lengths results as:\n\ndef s_0(s_p:float, R_p:float, alpha_tot: float, p: float):\n  \"\"\"total path length of the partial euler bend\"\"\"\n  return 2*s_p + R_p*alpha_tot*(1-p)\n\n\ndef eval_params(alpha_tot: float, p: float):\n  _R_0 = R_0()\n  _s_p = s_p(_R_0, alpha_tot, p)\n  _R_p = R_p(_R_0, alpha_tot, p)\n  _s_0 = s_0(_s_p, _R_p, alpha_tot, p)\n  return _R_0, _s_p, _R_p, _s_0\n\ndef partial_euler_unscaled(alpha_tot: float, p: float):\n  \n  R_0, s_p, R_p, s_0 = eval_params(alpha_tot, p)\n\n  y_p, x_p = fresnel(s_p)\n  pa_2 = p*alpha_tot/2\n  delta_x = x_p - R_p*np.sin(pa_2)\n  delta_y = y_p - R_p*(1-np.cos(pa_2))\n\n  def arg(s):\n    \"\"\"Used to simplify the expressions a bit\"\"\"\n    return (s-s_p)/R_p + pa_2\n\n\n  def x_bend(s):\n    if s&lt;0 or s&gt;s_0/2:\n      raise ValueError()\n\n    if s&gt;s_p:\n      return R_p*np.sin(arg(s)) + delta_x\n    else:\n      y, x = fresnel(s)\n      return x\n\n  def y_bend(s):\n    if s&lt;0 or s&gt;s_0/2:\n      raise ValueError()\n\n    if s&gt;s_p:\n      return R_p*(1-np.cos(arg(s))) + delta_y\n    else:\n      y, x = fresnel(s)\n      return y\n  \n  return x_bend, y_bend, s_0\n\nIn the following we will be calculating the rescaling factor. We need to evaluate \\(x_{bend}(s_0/2)\\) and \\(y_{bend}(s_0/2)\\) for that purpose.\n\ndef euler_bend_scaled(alpha_tot: float, p: float, R_eff: float):\n  x_bend, y_bend, s_0 = partial_euler_unscaled(alpha_tot , p)\n  x_0 = x_bend(s_0/2)\n  y_0 = y_bend(s_0/2)\n  eta = R_eff / (y_0+x_0/np.tan(alpha_tot/2))\n\n  def xy_scaled_bend(s):\n    x = np.array([x_bend(s_i) for s_i in s])\n    y = np.array([y_bend(s_i) for s_i in s])\n    return x*eta, y*eta\n  \n  return xy_scaled_bend, eta"
  },
  {
    "objectID": "eulerbend.html#comparison-gdsfactory",
    "href": "eulerbend.html#comparison-gdsfactory",
    "title": "Euler Bend",
    "section": "Comparison gdsfactory",
    "text": "Comparison gdsfactory\nlet`s compare our results to gdsfactory\n\ndef partial_euler_bend(alpha_tot:float, p:float, R_eff:float, num_points:float=200, radii:Optional[np.ndarray]=None):\n  \"\"\"\n    evaluates the euler part of a partial euler bend + one point at the beginning and end of the circular part. \n    returns the x,y coordinates, radii and angles of points on the curve\n  \"\"\"\n  R_0, s_p, R_p, s_0 = eval_params(alpha_tot, p)\n\n  xy_scaled_bend, eta = euler_bend_scaled(alpha_tot, p, R_eff)\n\n  if radii is None:\n    s = np.linspace(0, s_p, num_points) # euler part\n    radii = eta * R_0**2/(s+eps) \n  else:\n    s = eta * R_0**2/radii\n    radii = radii[s&lt;s_p]\n    s = s[s&lt;s_p] #don't go overboard\n\n  angles = (s/R_0)**2/2\n\n  # Add in center point\n\n  radii = np.append(radii, [R_p*eta]*2)\n  s = np.append(s, [s_p, s_0/2])\n  angles = np.append(angles, [alpha_tot/2*p, alpha_tot/2])\n  length = s*eta\n\n  return *xy_scaled_bend(s), radii, angles, length\n\n\nplt.figure(figsize=(3, 3))\nplt.title(\"partial euler bend\")\nplt.xlim(0,R_eff)\nplt.ylim(0,R_eff)\n\nx, y, radii, angles, l = partial_euler_bend(alpha_tot, p, R_eff)\nplt.scatter(x, y, marker = \".\", label=\"this implementation\")\nplt.scatter(R_eff-y, R_eff-x, marker = \".\")\n\nimport gdsfactory as gf\npa = gf.path.euler(radius=R_eff, angle=90, p=0.5, use_eff=True, npoints=720)\nplt.plot(pa.points[:,0], pa.points[:,1], \"k--\", linewidth=0.4, label=\"gdsfactory\")\n\nplt.grid()\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend(loc=\"upper left\")"
  },
  {
    "objectID": "eulerbend.html#straight-geometry",
    "href": "eulerbend.html#straight-geometry",
    "title": "Euler Bend",
    "section": "Straight Geometry",
    "text": "Straight Geometry\n\n@lru_cache(maxsize=None)\ndef create_geometry(L=2.0, w=w, t_core=t_core, t_ox=t_ox, t_slab=t_slab):\n    core_ox = mw.Structure(\n        material=mw.silicon_oxide,\n        geometry=mw.Box(\n            x_min=-w / 2 - t_ox / 2,\n            x_max=w / 2 + t_ox / 2,\n            y_min=0.0,\n            y_max=t_core + t_ox,\n            z_min=-L / 2,\n            z_max=L / 2,\n        ),\n    )\n\n    slab_ox = mw.Structure(\n        material=mw.silicon_oxide,\n        geometry=mw.Box(\n            x_min=-4,\n            x_max=4,\n            y_min=-2.0,\n            y_max=t_slab + t_ox,\n            z_min=-L / 2,\n            z_max=L / 2,\n        ),\n    )\n\n    core = mw.Structure(\n        material=mw.silicon,\n        geometry=mw.Box(\n            x_min=-w / 2,\n            x_max=w / 2,\n            y_min=0.0,\n            y_max=t_core,\n            z_min=-L / 2,\n            z_max=L / 2,\n        ),\n    )\n\n    slab = mw.Structure(\n        material=mw.silicon,\n        geometry=mw.Box(\n            x_min=-4,\n            x_max=4,\n            y_min=0.0,\n            y_max=t_slab,\n            z_min=-L / 2,\n            z_max=L / 2,\n        ),\n    )\n\n    return [slab_ox, core]#[core_ox, slab_ox, core, slab]\n\n\nmw.visualize(create_geometry(), scale=(1.0, 1.0, 5.0))"
  },
  {
    "objectID": "eulerbend.html#cell",
    "href": "eulerbend.html#cell",
    "title": "Euler Bend",
    "section": "Cell",
    "text": "Cell\n\ndef create_cell(bend_radius, L, w=w, t_core=t_core, t_ox=t_ox, t_slab=t_slab):\n    structs = create_geometry(L=L, w=w, t_core=t_core, t_ox=t_ox, t_slab=t_slab)\n    cell = mw.Cell(\n        structures=structs,\n        mesh=mw.Mesh2d(  # decrease approx_dy for more accuracy\n            x=_mesh_x(-2.5, 2.5, w, approx_dx=0.05),\n            y=_mesh_y(-1.5, 1.5, t_core, approx_dy=0.05),\n            bend_radius=bend_radius,\n            bend_axis=0,\n            num_pml=(10, 10),\n        ),\n        z_min=-L / 2,\n        z_max=L / 2,\n    )\n    return cell\n\n\n@lru_cache(maxsize=None)\ndef _mesh_y(start, stop, height_core, approx_dy=0.02):\n    \"\"\"special meshing that makes the pixel boundaries coincide with structure boundaries for better accuracy\"\"\"\n    num_cells = int(abs(stop - start) / approx_dy + 0.5)\n    num_core_cells = int(height_core / approx_dy + 0.5)\n    dy = height_core / num_core_cells\n    y = np.arange(start, stop, dy)\n    idx = np.argmin(abs(y))\n    y -= y[idx]\n    y = _make_length(y, num_cells)\n    # print(y.shape, y[:2] - y[0])\n    return y\n\n\n@lru_cache(maxsize=None)\ndef _mesh_x(start, stop, width_core, approx_dx=0.02):\n    \"\"\"special meshing that makes the pixel boundaries coincide with structure boundaries for better accuracy\"\"\"\n    num_cells = int(abs(stop - start) / approx_dx + 0.5)\n    num_core_cells = int(width_core / approx_dx + 0.5)\n    dx = width_core / num_core_cells\n    x = np.arange(start, stop, dx)\n    idx = np.argmin(abs(x - width_core / 2))\n    x -= x[idx]\n    x += width_core / 2\n    x = _make_length(x, num_cells)\n    # print(x.shape, x[:2] - x[0])\n    return x\n\n\ndef _make_length(x, L):\n    if x.shape[0] &gt; L:\n        return x[:L]\n    elif x.shape[0] == L:\n        return x\n    else:\n        dx = x[-1] - x[-2]\n        N = L - x.shape[0]\n        extra = np.array([x[-1] + (n + 1) * dx for n in range(N)])\n        x = np.concatenate([x, extra], 0)\n        return x\n\n\n#mw.visualize(create_cell(bend_radius=50.0, L=10))"
  },
  {
    "objectID": "eulerbend.html#cross-section",
    "href": "eulerbend.html#cross-section",
    "title": "Euler Bend",
    "section": "Cross Section",
    "text": "Cross Section\nWe can create a cross section from a cell as follows:\n\ndef create_cross_section(\n    bend_radius, L, w=w, t_core=t_core, t_ox=t_ox, t_slab=t_slab, wl=wl_mean, T=T\n):\n    env = mw.Environment(\n        wl=wl,\n        T=T,\n    )\n    if bend_radius&gt;1e10:\n        bend_radius = None\n    cs = mw.CrossSection(\n        cell=create_cell(bend_radius, L=L, w=w, t_core=t_core, t_ox=t_ox, t_slab=t_slab),\n        env=env,\n    )\n    return cs\n\n\nmw.visualize(create_cross_section(bend_radius=50.0, L=10))\n\n/home/jovyan/meow/meow/cross_section.py:89: MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3.  Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading'].  This will become an error two minor releases later.\n  plt.pcolormesh(\n\n\n\n\n\n\nNote: bend radius is not visualized on cross section visualizations"
  },
  {
    "objectID": "eulerbend.html#multiple-cross-sections",
    "href": "eulerbend.html#multiple-cross-sections",
    "title": "Euler Bend",
    "section": "Multiple Cross Sections",
    "text": "Multiple Cross Sections\n\ndef sample_euler_radii(\n    num_cells: int, R_eff_min: float, R_eff: float, alpha_tot:float, p:float\n):\n  \"\"\"\n    sample the euler bend on a equidistant curvature grid.\n     Args:\n        num_cells: number of samples taken from the curve\n        R_eff_min: minimum R_eff for subsequent sweep, to reuse radii/modes\n        R_eff: effective Radius for this run\n        alpha_tot: angle of the complete partial euler bend\n        p: part of bend that is euler (in contrast to circular)\n  \"\"\"\n\n  curvatures = np.linspace(eps,1/R_eff_min, num_cells-3)\n\n  dcurvatures = np.diff(curvatures) #halfinteger grid\n  curvatures_ = curvatures[:-1] + dcurvatures/2\n\n  def prepareSlices(curvs):\n    radii = 1/curvs\n    return partial_euler_bend(alpha_tot, p, R_eff, radii=radii)\n\n  x,y,r,a,l      = prepareSlices(curvatures)\n  x_,y_,r_,a_,l_ = prepareSlices(curvatures_)\n\n  return l, r, l_, r_\n\n\nl, r, l_, r_ = sample_euler_radii(num_cells, R_eff_min, R_eff, alpha_tot, p)\ns_gf, curv_gf = pa.curvature()\nradii_gf = 1/curv_gf\n\nplt.figure(figsize=(4, 2.5))\nplt.title(\"Euler radius vs length\")\nplt.plot(s_gf, radii_gf, label=\"gdsfactory\")\nplt.plot(l,r, marker=\"x\", label=\"this implementation\")\n#plt.xlim(0, R_eff/2)\nplt.ylim(0, R_eff*8)\nplt.grid(True)\nplt.xlabel(\"euler bend length [um]\")\nplt.ylabel(\"radius [um]\")\nplt.legend()\n\n\n\n\n\ndef sample_cross_sections(\n    num_cells: int, R_eff_min: float, R_eff: float, alpha_tot:float, p:float\n):\n    l, r, l_, r_ = sample_euler_radii(num_cells, R_eff_min, R_eff, alpha_tot, p)\n    Rs = np.concatenate([[1e100], r_, [r[-1]]])  # always good to have a zero-length cell at start and end.\n    Ls = np.concatenate([[0], np.diff(l), [0]])  # always good to have a zero-length cell at start and end.\n    return [create_cross_section(R, L, wl=wl_mean) for R, L in zip(Rs, Ls)]"
  },
  {
    "objectID": "eulerbend.html#calculate-modes",
    "href": "eulerbend.html#calculate-modes",
    "title": "Euler Bend",
    "section": "Calculate Modes",
    "text": "Calculate Modes\n\nfrom skill_challenge.util import cMode\n\n\ndef calculate_modes(\n    num_cells: int, R_eff_min: float, R_eff: float, alpha_tot:float, p:float\n):\n    css = sample_cross_sections(num_cells, R_eff_min, R_eff, alpha_tot, p)\n    return [cachedComputeModes(cs, num_modes) for cs in tqdm(css, leave=False)]\n\n\nmodes = calculate_modes(num_cells, R_eff_min, R_eff, alpha_tot, p)\nfor m in modes[0]:\n  print(hash(cMode(mode = m)))\n\n\n\n\n\nmw.visualize(modes[0][0])\nmw.visualize(modes[-1][0])"
  },
  {
    "objectID": "eulerbend.html#calculate-s-matrix",
    "href": "eulerbend.html#calculate-s-matrix",
    "title": "Euler Bend",
    "section": "Calculate S-matrix",
    "text": "Calculate S-matrix\n\nfrom meow.eme import compute_interface_s_matrix as originalInterface\nfrom typing import Tuple, List\nfrom meow import Mode\n\n@lru_cache(maxsize=None)\ndef innerInterface( modes1: Tuple[cMode], \n                    modes2: Tuple[cMode], \n                    *args, **kwargs):\n  #print(\"recalculating\")\n  result = originalInterface(\n      [m.getMode() for m in modes1],\n      [m.getMode() for m in modes2],\n      *args, **kwargs\n  )\n  return result\n\n\ndef cachedComputeInterfaces(modes: List[List[Mode]], *args, **kwargs):\n  \"\"\"get all the S-matrices of all the interfaces in a collection of `CrossSections`\"\"\"\n  return {\n      f\"i_{i}_{i + 1}\": cachedSingle(\n          modes1=modes1,\n          modes2=modes2,\n          *args, **kwargs\n      )\n      for i, (modes1, modes2) in enumerate(zip(modes[:-1], modes[1:]))\n  }\n\ndef cachedSingle(modes1: List[cMode], \n                 modes2: List[cMode], *args, **kwargs):\n  #print(\"searching cache\")\n  return innerInterface(\n      tuple([cMode(mode=m) for m in modes1]),  \n      tuple([cMode(mode=m) for m in modes2]), \n      *args, **kwargs\n    )\n\n\nimport xarray as xr\nfrom tqdm.notebook import tqdm\nresults_tot = []\nfor i, _R_eff in enumerate(tqdm(R_eff_sweep)):\n  results_reff = []\n  for _p in tqdm(p_sweep, leave=False):\n    modes = calculate_modes(num_cells, R_eff_min, _R_eff, alpha_tot, _p)\n    S, port_map = mw.compute_s_matrix(modes, compute_interface_s_matrices = cachedComputeInterfaces) #sax_backend=\"klu\"\n    results_reff.append(np.abs(S))\n  results_tot.append(results_reff)\n\n  results = xr.DataArray(results_tot, dims=(\"R_eff\", \"p\", \"port_in\", \"port_out\"), coords={\"R_eff\": R_eff_sweep[:i+1], \"p\": p_sweep})\n  results.to_netcdf('euler_sweep_tmp.nc')"
  },
  {
    "objectID": "optimizing_mmi.html",
    "href": "optimizing_mmi.html",
    "title": "How to optimize the transmission of an MMI",
    "section": "",
    "text": "This notebook uses Tidy3D, which is a high performance FDTD solver, that allows for gradient computation using the adjoint method (see tutorial here). In this notebook we will use such gradient computation to perform a gradient descent optimization of the power transmission of a 2x2 MMI. For a structure that will be fabricated full 3D simulations should be performed. As I am limited in terms of compute / flex-credit I will however resort to demonstrating the optimization in 2D here.\nTo avoid resimulating the same simulations over and over again I introduced a rudimentary simulation cache to Tidy3D here. To also locate “old” simulations not yet idexed one can run:\nimport tidy3d.web.sim_cache as sc\n_ = sc.build_sim_cache()\n\nfound existing\nno tasks in folder\nno tasks in folder\nAs stated above we will only run in 2D here. Feel free to set is3D to True to run in 3D. The waveguides are rather wide (above the single mode cutoff), which is a substitution for the otherwise employed tapers.\nwg_width = 1.5\nwg_height = 0.22\nwg_offset = 3.2\nlength_sim = 82\nport_pad = 2\nwidth_sim = 7.5\nis3D = False\nif is3D:\n  ncore=2\n  nclad=1.45\nelse:\n  ncore=1.647\n  nclad=1.45\n\nwavelength = 1.55\nfreq0 = td.C_0 / wavelength\ndl = 0.02"
  },
  {
    "objectID": "optimizing_mmi.html#simulation-setup",
    "href": "optimizing_mmi.html#simulation-setup",
    "title": "How to optimize the transmission of an MMI",
    "section": "Simulation Setup",
    "text": "Simulation Setup\nTo make the simulation differentiable with respect to the MMI dimensions we will use a JaxSimulation from tidy3d.plugins.adjoint.\n\ndef make_simulation(width: float, length: float) -&gt; JaxSimulation:\n    \"\"\"Makes a simulation with a variable mmi width and length.\"\"\"\n\n    # a \"static\" structure\n    waveguides = []\n    for sign in [1, -1]:\n      waveguides.append(td.Structure(\n        geometry=td.Box(\n          size=(td.inf, wg_width, wg_height),\n          center=(0,sign*0.5*wg_offset,0)),\n          medium=td.Medium(permittivity=ncore**2),\n      ))\n\n    # our \"forward\" soruce\n    mode_width = max(wg_offset, wg_width*2)\n    mode_src = td.ModeSource(\n        size=(0, mode_width, td.inf),\n        center=(-length_sim/2+port_pad, 0.5*wg_offset, 0),\n        mode_index=0,\n        source_time=td.GaussianPulse(freq0=freq0, fwidth=freq0 / 10),\n        direction=\"+\",\n    )\n\n    # a monitor to store data that our overall function will depend on\n    mnts = []\n    for name, sign in zip([\"thru\",\"drop\"],[1, -1]):\n      mnts.append(td.ModeMonitor(\n        size=(0, mode_width, td.inf),\n        center=(length_sim/2-port_pad, sign*0.5*wg_offset, 0),\n        mode_spec=mode_src.mode_spec,\n        freqs=[freq0],\n        name=name,\n      ))\n\n    field_mnt = td.FieldMonitor(\n      size=(td.inf, td.inf, 0),\n      freqs=[freq0],\n      name=\"field_mnt\",\n    )\n\n    # the structure that depends on the input parameters, which we will differentiate our function w.r.t\n    mmi = JaxStructure(\n        geometry=JaxBox(\n            center=(0,0,0),\n            size=(length, width, wg_height),\n        ),\n        medium=JaxMedium(permittivity=ncore**2),\n    )\n\n    return JaxSimulation(\n        size=(length_sim, width_sim, 2.5 if is3D else 0),\n        medium=td.Medium(permittivity=nclad**2),\n        run_time=2e-12,\n        structures=waveguides,\n        input_structures=[mmi],\n        sources=[mode_src],\n        output_monitors=mnts,\n        monitors=[field_mnt],#, source_mnt],\n        boundary_spec=td.BoundarySpec.pml(x=True, y=True, z=False),\n        grid_spec=td.GridSpec.uniform(dl=dl),\n    )\n\n\nEyes on the simulation\nlet’s plot the proposed simulation\n\nimport matplotlib.pyplot as plt\n# starting set of input parameters\nwidth0=5.4\nlength0=10\n\njax_sim = make_simulation(width=width0, length=length0)\n_, axes = plt.subplots(1, 3, figsize=(10, 10))\n\n# sim, _ = jax_sim.to_simulation()\nfor ax, dim in zip(axes, \"xyz\"):\n    jax_sim.plot(**{dim: 0}, ax=ax)\nplt.show()"
  },
  {
    "objectID": "optimizing_mmi.html#initial-guess",
    "href": "optimizing_mmi.html#initial-guess",
    "title": "How to optimize the transmission of an MMI",
    "section": "Initial Guess",
    "text": "Initial Guess\nTo get a good initial guess for the geometry (the length) we will use the methodology introduced in the ‘Intoduction to MMIs’ notebook.\n\nfrom tidy3d.plugins.mode import ModeSolver\nimport numpy as np\n\nnum_modes = 10\nmode_spec = td.ModeSpec(num_modes=num_modes, filter_pol=\"te\")\n\ncenter_plane = td.Box(center=(0,0,0), size=(0,td.inf, td.inf))\ninput_plane = td.Box(\n    size=(0, 1.5, 1.5),\n    center=(-length_sim/2+port_pad, 0.5*wg_offset, 0)\n)\n\nmode_solver = ModeSolver(\n    simulation=jax_sim.to_simulation()[0], plane=center_plane, mode_spec=mode_spec, freqs=[freq0]\n)\nmodes = mode_solver.solve()\n\nprint(\"Effective index of computed modes: \", np.array(modes.n_eff))\n\n\nfor mode_ind in range(num_modes//2):\n    field = modes.field_components[\"Ey\"].sel(mode_index=mode_ind)\n    plt.plot(field.real.y, np.squeeze(field.real) - mode_ind*30, label=f\"TE{mode_ind}\")\n    plt.axhline(-mode_ind*30, linestyle=\"--\", color=\"k\")\n\nplt.xlabel(\"y [um]\")\nplt.yticks([])\nif not is3D:\n    plt.legend()\n\nEffective index of computed modes:  [[1.641746  1.626001  1.5997876 1.5633625 1.5179322 1.6420181 1.6270313\n  1.6019529 1.566696  1.5213424]]\n\n\n\n\n\nAs seen the multimode section supports x Modes (depending on width, index contrast).\n\nd_neff = modes.n_eff.sel(mode_index=0)-modes.n_eff.sel(mode_index=1)\nk0 = 2*np.pi/wavelength\nl_pi = np.pi/(k0*d_neff)\nl_pi = float(np.real(l_pi))\n\n\nlength0 = l_pi*3/2\nlength0\n\n73.83275413513184\n\n\nLet’s revalidate that the simulation for our chosen initial guess looks good\n\njax_sim = make_simulation(width=width0, length=length0)\n_, axes = plt.subplots(1, 3, figsize=(16, 20))\n\n# sim, _ = jax_sim.to_simulation()\nfor ax, dim in zip(axes, \"xyz\"):\n    jax_sim.plot(**{dim: 0}, ax=ax)\nplt.show()"
  },
  {
    "objectID": "optimizing_mmi.html#objective-function",
    "href": "optimizing_mmi.html#objective-function",
    "title": "How to optimize the transmission of an MMI",
    "section": "Objective Function",
    "text": "Objective Function\nWe will have to define some objective to optimize. Here we will use the worst case transmission (of the “thru” and “drop” ports). To do so the per port objective function is defined as \\(0.5-P_{port}\\).\n\nfrom tidy3d.plugins.adjoint import JaxSimulationData\nfrom tidy3d.plugins.adjoint.web import run as run_adjoint\ndef compute_powers(jax_sim_data: JaxSimulationData) -&gt; float:\n    \"\"\"Post process the result of the JaxSimulation run to return the power in the modes at index=0.\"\"\"\n\n    freq0 = jax_sim_data.simulation.output_monitors[0].freqs[0]\n\n    pows = []\n    for name in [\"thru\", \"drop\"]:\n      jax_mode_data = jax_sim_data.output_monitor_data[name]\n      mode_amps = jax_mode_data.amps\n      amp = mode_amps.sel(direction=\"+\", f=freq0, mode_index=0)\n      jax.debug.print(f\"{name}: |.|={{abs}} /_={{ang}}\", abs=jnp.abs(amp), ang=jnp.rad2deg(jnp.angle(amp)))\n      pows.append(abs(amp) ** 2)\n    return pows\n\nTo optimize for the worst case we will want to minimize the maximum of those objective functions. The same idea would apply across frequencies, if we were looking for broadband behavior. To avoid “jumping” between optimizing one port’s transmission while deteriorating the other, let’s “smoothen” the maximum function a bit.\n\ndef plot_field(sim_data):\n    f, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 6))\n    ax1 = sim_data.plot_field(\"field_mnt\", \"Ez\", z=0, ax=ax1)\n    ax2 = sim_data.plot_field(\"field_mnt\", \"E\", \"abs^2\", z=0, ax=ax2)\n    plt.show()\n\ndef loss_fn(x) -&gt; float:\n    \"\"\".\"\"\"\n    width = x[0]\n    length = x[1]\n    jax_sim = make_simulation(width=width, length=length)\n    jax_sim_data = run_adjoint(jax_sim, task_name=\"adjoint_power\", verbose=True)\n    jax.debug.callback(plot_field, jax_sim_data)\n    pows = compute_powers(jax_sim_data)\n    losss = 0.5-jnp.array(pows)\n    return jnp.inner(jax.nn.softmax(losss*max_weight), losss)"
  },
  {
    "objectID": "optimizing_mmi.html#differentiation",
    "href": "optimizing_mmi.html#differentiation",
    "title": "How to optimize the transmission of an MMI",
    "section": "Differentiation",
    "text": "Differentiation\nas the loss function is fully differentiable by JAX (including the maxwell simulation) we can simply use JAX’s gadient functionality:\n\ngrad_fn = jax.value_and_grad(loss_fn)\n\n\nfrom tqdm.notebook import trange\nfrom jax.example_libraries.optimizers import adam\nimport numpy as np"
  },
  {
    "objectID": "optimizing_mmi.html#optimization",
    "href": "optimizing_mmi.html#optimization",
    "title": "How to optimize the transmission of an MMI",
    "section": "Optimization",
    "text": "Optimization\nLet’s set up an optimization:\n\nstep_size = 0.01\ninit_fn, update_fn, params_fn = adam(step_size)\n\ndef step_fn(step, state):\n    latent = params_fn(state)\n    print(latent)\n    loss, grads = grad_fn(latent)\n\n    optim_state = update_fn(step, grads, state)\n\n    return loss, optim_state\n\nstep=0\nstate = init_fn(jnp.array([width0, length0]))\nlosses = []\ndims = []\n\nand run it over some steps. For better results more steps should be performed…\n\nNsteps=20\nrange_ = trange(step, step+Nsteps)\nmax_weight = 50 \nfor step in range_:\n    if step &gt;= 13:\n      max_weight = 100 #let's put a stronger emphasis on balanced output after some steps\n    loss, state = step_fn(step, state)\n    print(loss)\n    losses.append(loss)\n    dims.append(params_fn(state))\n    range_.set_postfix(loss=float(loss))\n\n\n\n\n[ 5.343209 73.88902 ]\nthru: |.|=0.6714630126953125 /_=82.4566421508789\ndrop: |.|=0.6893093585968018 /_=-5.175093173980713\n0.043577366\n[ 5.3346734 73.89701  ]\nthru: |.|=0.6735112071037292 /_=80.9915771484375\ndrop: |.|=0.6948578357696533 /_=-6.92050313949585\n0.04087977\n[ 5.326499 73.90453 ]\nthru: |.|=0.6749585270881653 /_=79.91184997558594\ndrop: |.|=0.6983233690261841 /_=-8.242425918579102\n0.039060425\n[ 5.318555 73.91167 ]\nthru: |.|=0.6754379272460938 /_=79.5990219116211\ndrop: |.|=0.6994077563285828 /_=-8.644887924194336\n0.038464222\n[ 5.3107715 73.918465 ]\nthru: |.|=0.676282525062561 /_=78.96717834472656\ndrop: |.|=0.7011749744415283 /_=-9.44028377532959\n0.037409816\n[ 5.30313 73.92493]\nthru: |.|=0.6777359843254089 /_=77.74712371826172\ndrop: |.|=0.7038779854774475 /_=-10.979950904846191\n0.035576463\n[ 5.2956395 73.93115  ]\nthru: |.|=0.6791608929634094 /_=76.40271759033203\ndrop: |.|=0.7060542702674866 /_=-12.696433067321777\n0.0337339\n[ 5.2884173 73.937126 ]\nthru: |.|=0.6801576018333435 /_=75.32466888427734\ndrop: |.|=0.7072086334228516 /_=-14.0813627243042\n0.03240196\n[ 5.2814083 73.94283  ]\nthru: |.|=0.680593729019165 /_=74.79725646972656\ndrop: |.|=0.7075856924057007 /_=-14.75925350189209\n0.031803515\n[ 5.2745795 73.94831  ]\nthru: |.|=0.6808004379272461 /_=74.5257797241211\ndrop: |.|=0.7077338695526123 /_=-15.112287521362305\n0.03151614\n[ 5.267922 73.953575]\nthru: |.|=0.6813574433326721 /_=73.64881896972656\ndrop: |.|=0.7079594731330872 /_=-16.238290786743164\n0.030721372\n[ 5.261475 73.95856 ]\nthru: |.|=0.6819174885749817 /_=72.49040985107422\ndrop: |.|=0.7077907919883728 /_=-17.727436065673828\n0.029878546\n[ 5.255311 73.96315 ]\nthru: |.|=0.682266891002655 /_=71.33556365966797\ndrop: |.|=0.7071109414100647 /_=-19.213376998901367\n0.02929577\n[ 5.24956 73.96723]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:47:54] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n[11:47:56] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:07] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:09] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:10] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:22] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:24] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:25] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:36] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:38] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:39] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:51] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:53] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n[11:48:54] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:08] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:10] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:11] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:22] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:24] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:29] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:41] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:42] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:44] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:55] status = success                                                                           webapi.py:336\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:57] Created task 'adjoint_power' with task_id 'fdve-eaf33ba6-93b7-4600-b27a-22f31ac1a926v1'.   webapi.py:200\n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-eaf33ba6-93b7-4600-b27a-22f31ac1a92              \n           6v1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:49:59] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:50:07] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:50:11] Maximum FlexCredit cost: 0.035. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n           running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:50:23] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:50:51] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:50:54] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:51:05] Created task 'adjoint_power_adj' with task_id                                              webapi.py:200\n           'fdve-f0cee323-e510-4646-8f75-dfa3184a42b4v1'.                                                          \n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-f0cee323-e510-4646-8f75-dfa3184a42b              \n           4v1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:51:07] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:51:09] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:51:13] Maximum FlexCredit cost: 0.031. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n           running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:51:24] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:51:31] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:51:33] Created task 'adjoint_power' with task_id 'fdve-73f78262-9598-4bf9-81b2-025f16a67634v1'.   webapi.py:200\n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-73f78262-9598-4bf9-81b2-025f16a6763              \n           4v1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:51:35] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:51:42] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:51:47] Maximum FlexCredit cost: 0.035. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n           running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:52:01] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:52:29] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:52:31] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:52:43] Created task 'adjoint_power_adj' with task_id                                              webapi.py:200\n           'fdve-36d9bb22-c62c-4368-b640-049c0493bd2dv1'.                                                          \n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-36d9bb22-c62c-4368-b640-049c0493bd2              \n           dv1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:52:44] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:52:47] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:52:54] Maximum FlexCredit cost: 0.031. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n           running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:53:07] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:53:20] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:53:22] Created task 'adjoint_power' with task_id 'fdve-360dd00a-c45e-4020-ad91-2303f770fc45v1'.   webapi.py:200\n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-360dd00a-c45e-4020-ad91-2303f770fc4              \n           5v1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:53:24] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:53:27] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:53:33] Maximum FlexCredit cost: 0.035. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n[11:53:34] running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:53:48] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:54:26] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:54:29] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:54:41] Created task 'adjoint_power_adj' with task_id                                              webapi.py:200\n           'fdve-4ee0133c-0dc4-4b0d-9421-466cc4765323v1'.                                                          \n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-4ee0133c-0dc4-4b0d-9421-466cc476532              \n           3v1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:54:42] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:54:49] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:54:54] Maximum FlexCredit cost: 0.031. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n           running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:55:06] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:55:14] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:55:16] Created task 'adjoint_power' with task_id 'fdve-419636f7-0436-4a02-a2d8-cb15248c50d3v1'.   webapi.py:200\n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-419636f7-0436-4a02-a2d8-cb15248c50d              \n           3v1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:55:18] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:55:20] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:55:24] Maximum FlexCredit cost: 0.035. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n           running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:55:38] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:56:03] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:56:05] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:56:17] Created task 'adjoint_power_adj' with task_id                                              webapi.py:200\n           'fdve-d410e11b-734f-4ad2-a42d-a99fefd3f03av1'.                                                          \n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-d410e11b-734f-4ad2-a42d-a99fefd3f03              \n           av1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:56:19] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:56:21] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:56:28] Maximum FlexCredit cost: 0.031. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n[11:56:29] running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:56:42] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:56:55] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:56:57] Created task 'adjoint_power' with task_id 'fdve-017c260d-879d-4ee9-a097-0e183ce1faa1v1'.   webapi.py:200\n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-017c260d-879d-4ee9-a097-0e183ce1faa              \n           1v1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:56:59] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:57:08] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:57:12] Maximum FlexCredit cost: 0.035. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n           running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:57:24] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:57:50] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:57:53] loading SimulationData from simulation_data.hdf5                                           webapi.py:583\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:58:04] Created task 'adjoint_power_adj' with task_id                                              webapi.py:200\n           'fdve-ba2efd69-719a-43f3-b8e2-3be1bbe01e33v1'.                                                          \n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-ba2efd69-719a-43f3-b8e2-3be1bbe01e3              \n           3v1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:58:06] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:58:08] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:58:14] Maximum FlexCredit cost: 0.031. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n           running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:58:26] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n[11:58:34] status = success                                                                           webapi.py:405\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:58:36] Created task 'adjoint_power' with task_id 'fdve-176c948a-2e07-4e94-bed4-fe969f9fa336v1'.   webapi.py:200\n\n\n\n           View task using web UI at                                                                  webapi.py:202\n           'https://tidy3d.simulation.cloud/workbench?taskId=fdve-176c948a-2e07-4e94-bed4-fe969f9fa33              \n           6v1'.                                                                                                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[11:58:37] status = queued                                                                            webapi.py:336\n\n\n\n\n\n\n[11:58:40] status = preprocess                                                                        webapi.py:330\n\n\n\n\n\n\n[11:58:47] Maximum FlexCredit cost: 0.035. Use 'web.real_cost(task_id)' to get the billed FlexCredit  webapi.py:353\n           cost after a simulation run.                                                                            \n\n\n\n           starting up solver                                                                         webapi.py:357\n\n\n\n           running solver                                                                             webapi.py:367\n\n\n\n\n\n\n[11:59:02] early shutoff detected, exiting.                                                           webapi.py:381\n\n\n\n\n\n\n\n\n\n           status = postprocess                                                                       webapi.py:398\n\n\n\n\n\n\n\n\n\nKeyboardInterrupt: ignored\n\n\n\nplt.plot(losses)"
  },
  {
    "objectID": "mmi_eme.html",
    "href": "mmi_eme.html",
    "title": "How to propagate fields in meow",
    "section": "",
    "text": "import gdsfactory as gf\nimport meow as mw\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.rcParams[\"pcolor.shading\"]=\"auto\"\n\n2023-11-14 08:56:39.030 | INFO     | gdsfactory.config:__init__:205 - LogLevel: INFO\n\n\n\ntry:\n    import klujax\nexcept:\n    import warnings\n    warnings.warn(\"Klujax could not be loaded falling back to default backend for sax, which is going to be slow\")\n\n\ndef example_extrusions(\n    t_slab: float = 0.0,\n    t_soi: float = 0.4,\n    t_ox: float = 0.0,\n):\n    \"\"\" create some simple extrusion rules\n    \n    Args:\n        t_slab: the slab thickness\n        t_soi: the SOI thickness\n        t_ox: the oxide layer thickness\n    \"\"\"\n    extrusions = {\n        (1, 0): [\n            mw.GdsExtrusionRule(\n                material=mw.silicon,\n                h_min=0.0,\n                h_max=0.0 + t_soi,\n                mesh_order=1,\n            ),\n        ],\n    }\n    return extrusions\n\n\nl_taper=10\nl_center=20\nw_center=3\n\nmmi = gf.components.mmi2x2(length_taper=l_taper, \n   length_mmi=l_center, \n   width_mmi=w_center)\n\nc = gf.Component()\nref = c.add_ref(mmi)\nref.xmin = 0\nmmi = c\n\nextrusion_rules = example_extrusions()\nstructs = mw.extrude_gds(mmi, extrusion_rules)\n\n#mw.visualize(structs, scale=(1, 1, 0.2))\n\n\nmmi.plot()\n\nYou can install `pip install gdsfactory[cad]` for better visualization\n\n\n/home/jd/work/side/skill-challenge/.venv/lib/python3.10/site-packages/gdsfactory/component.py:1538: UserWarning: Component 'Unnamed_eee44b9e' contains 1 Unnamed cells\n  gdspath = component.write_gds(logging=False)\n\n\n\n\n\n\neps = 1e-10\nw_sim = w_center + 2\nh_sim = 2.0\nmesh = 100\nnum_cells = 10\nLs = [l_taper / num_cells]*num_cells\nLs[-1] -= eps\nLs[0] -= eps\nLs += [2*eps, l_center-2*eps, 2*eps] + Ls\nLs = [eps] + Ls + [eps]\nprint(Ls)\n\ncells = mw.create_cells(\n    structures=structs,  \n    mesh=mw.Mesh2d(\n        x=np.linspace(-w_sim/2, w_sim/2, mesh + 1),\n        y=np.linspace(-h_sim/2, h_sim/2, mesh + 1),\n    ),\n    Ls=Ls\n)\n\n#for cell in cells:\n# mw.visualize(cell)\n\n[1e-10, 0.9999999999, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.9999999999, 2e-10, 19.9999999998, 2e-10, 0.9999999999, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.9999999999, 1e-10]\n\n\n\nenv = mw.Environment(wl=1.55, T=25.0)\ncss = [mw.CrossSection(cell=cell, env=env) for cell in cells]\n\nmw.visualize(css[0])\nmw.visualize(css[-1])\n\n\n\n\n\n\n\n\nnum_modes=10\n\n\nfrom tqdm.notebook import tqdm\nmodes = [mw.compute_modes(cs, num_modes=num_modes) for cs in tqdm(css)]\n\n\n\n\n\nimport pickle\nwith open(f\"../assets/modes.pkl\", \"wb\") as file:\n    pickle.dump(modes, file)\n\n\nmodes[0] = [modes[0][0] + modes[0][1], modes[0][0] - modes[0][1]] \nmodes[-1] = [modes[-1][0] + modes[-1][1], modes[-1][0] - modes[-1][1]]\n\n\nfrom meow.mode import is_pml_mode\nmodes = [[m for m in modes_ if not is_pml_mode(m,0.3)] for modes_ in modes]\n\n\nmw.visualize(modes[0])\n\n\n\n\n\nS, port_map = mw.compute_s_matrix(modes)\nprint(port_map)\nmw.visualize(S)\n\n{'left@0': 0, 'left@1': 1, 'right@0': 2, 'right@1': 3}\n\n\n\n\n\n\nfrom meow.eme.propagate import propagate_modes\n\n\nz = np.linspace(0, l_taper*2+l_center, 1000)\nE, x = propagate_modes(modes, np.array([1,0]), np.array([0,0]), 0.2, z)\nX, Y = np.meshgrid(z, x)\nlim = np.quantile(np.abs(E), 0.98)\nplt.pcolormesh(X, Y, np.abs(E).T, shading=\"nearest\", cmap=\"magma\", vmin=0, vmax=lim)\n\n&lt;matplotlib.collections.QuadMesh&gt;\n\n\n\n\n\n\nz = np.linspace(0, l_taper*2+l_center, 1000)\nE, x = propagate_modes(modes, np.array([0,0]), np.array([1,1]), 0.2, z)\nX, Y = np.meshgrid(z, x)\nlim = np.quantile(np.abs(E), 0.98)\nplt.pcolormesh(X, Y, np.abs(E).T, shading=\"nearest\", cmap=\"magma\", vmin=0, vmax=lim)\n\n&lt;matplotlib.collections.QuadMesh&gt;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "phoss",
    "section": "",
    "text": "Hey everyone, my name is Jan David Fischbach. I have studied electrical engineering 💡 at RWTH University, where I graduated with a master’s degree in 2022 🎓. Attached are some examples of photonic integrated design.\nPlease find out more about me here."
  },
  {
    "objectID": "mmi_briefing.html",
    "href": "mmi_briefing.html",
    "title": "Intoduction to MMIs",
    "section": "",
    "text": "This notebook is largely based on [1]. It leverages meow to do EME calculations."
  },
  {
    "objectID": "mmi_briefing.html#multimode-waveguides",
    "href": "mmi_briefing.html#multimode-waveguides",
    "title": "Intoduction to MMIs",
    "section": "Multimode waveguides:",
    "text": "Multimode waveguides:\nA waveguide of apropriate size can support (guide) more than one mode (per polarization*) these are called multimode waveguides (we will only consider TE polarization in the following):\n\n\n\nMultimode.PNG\n\n\nModes of a 2D waveguide (from [1])\nThe set of supported (guided) eigenmodes represents an orthogonal basis to express arbitrary (guided) fields inside such multimode waveguides. As the propagation constants of different eigenmodes are usually distinct** the phase relation between the different modes will vary along the direction of propagation leading to spatial interference patterns. The different propagation constants show an almost quadratic dependence on the mode number ([1] eq. 4.4): \\[ \\beta_v \\approx k_0 n_r -\\frac{(v+1)^2\\pi\\lambda_0}{4n_cW_e^2}\\] where \\(v\\) is the mode number, \\(\\lambda_0\\) is the vacuum wavelength and \\(n_c\\) the refractive index of the core material. The effective width \\(W_e\\) is the width of the mode taking into account the penetration depth of the evanescent field. It is assumed to be independent of \\(v\\).\nThis relation leads to a propagation constant difference (compared to the fundamental mode) of ([1] eq. 4.6 typo corrected): \\[ \\beta_0 - \\beta_v = \\frac{v(v+2)\\pi}{3L_\\pi}\\] where \\(L_pi\\) is the beat length of modes 0 and 1.\nThus at position \\(z\\) along the waveguide the modes will have aquired a relative phase factor of: \\[P = e^{i\\frac{v(v+2)\\pi}{3L_\\pi}z}\\]\nNote that the relative phase factor of the fundamental mode is \\(1\\) everywhere per definition.\nFrom these phase factors we deduce special locations along the waveguide, where specific interference phenomena occurr. E.g. if all phase factors are equal (i.e. \\(1\\)) the same field distribution as at \\(z=0\\) will occurr. Switching the sign of the odd modes the original field distribution will be mirrored to the other side of the waveguide (\\(P=(-1)^v\\)).\nIt can be easily found [1] that these interferences occurr at \\(z=p(3L_\\pi)\\) with \\(p\\) an even integer for an unchanged image and \\(p\\) an odd integer for a mirrored image.\nInspecting the points inbetween mentioned positions one findes that the original and mirrored field distributions are superimposed in quadrature (see [1] eq. 4.20) which is the behavior we are looking for in this notebook. Note that other techniques can be used to selectively excite modes to create the interference pattern at smaller \\(z\\) leading to smaller footprint devices. This technique is considered out of the scope of the current task, as only an optimization of the power transmission has been requested.\n*see discussion in the single mode notebook\n**except for degenerate modes e.g. caused by symmetry\n[1] Sosa Andrade, Andrés: “Design of a silicon photonic multimode interference coupler.” (2012)\nLets create our C-Band environment for meow:\n\nenv = mw.Environment(\n    wl=1.55,\n    T=27,\n)"
  },
  {
    "objectID": "mmi_briefing.html#multimode-section",
    "href": "mmi_briefing.html#multimode-section",
    "title": "Intoduction to MMIs",
    "section": "Multimode Section",
    "text": "Multimode Section\nLet’s define the multimode section of the MMI of interest:\n\ndef create_multimode(L=1e3, w=2.3, t_core=0.4):\n    slab_ox = mw.Structure(\n        material=mw.silicon_oxide,\n        geometry=mw.Box(\n            x_min=-10,\n            x_max=10,\n            y_min=-2.0,\n            y_max=2.0,\n            z_min=-L / 2,\n            z_max=L / 2,\n        ),\n    )\n\n    core = mw.Structure(\n        material=mw.silicon_nitride,\n        geometry=mw.Box(\n            x_min=-w / 2,\n            x_max=w / 2,\n            y_min=0.0,\n            y_max=t_core,\n            z_min=-L / 2,\n            z_max=L / 2,\n        ),\n    )\n\n    return [slab_ox, core]"
  },
  {
    "objectID": "mmi_briefing.html#input-output",
    "href": "mmi_briefing.html#input-output",
    "title": "Intoduction to MMIs",
    "section": "Input Output",
    "text": "Input Output\nLet’s define some waveguide for i/o of the light.\n\ndef create_io(L=1e3, w=1, t_core=0.4, offset=1):\n    slab_ox = mw.Structure(\n        material=mw.silicon_oxide,\n        geometry=mw.Box(\n            x_min=-10,\n            x_max=10,\n            y_min=-2.0,\n            y_max=2.0,\n            z_min=-L / 2,\n            z_max=L / 2,\n        ),\n    )\n\n    core1 = mw.Structure(\n        material=mw.silicon_nitride,\n        geometry=mw.Box(\n            x_min=-w / 2 + offset,\n            x_max=w / 2  + offset,\n            y_min=0.0,\n            y_max=t_core,\n            z_min=-L / 2,\n            z_max=L / 2,\n        ),\n    )\n    \n    core2 = mw.Structure(\n        material=mw.silicon_nitride,\n        geometry=mw.Box(\n            x_min=-w / 2 - offset,\n            x_max=w / 2  - offset,\n            y_min=0.0,\n            y_max=t_core,\n            z_min=-L / 2,\n            z_max=L / 2,\n        ),\n    )\n    return [slab_ox, core1, core2]"
  },
  {
    "objectID": "mmi_briefing.html#crosssections",
    "href": "mmi_briefing.html#crosssections",
    "title": "Intoduction to MMIs",
    "section": "Crosssections",
    "text": "Crosssections\nLet’s stack the IO and multimode sections as subsequent meow.CrossSections\n\nio_width = 0.9\nw_tot = 4\ndef construct_css(L):\n    mesh = mw.Mesh2d(  # decrease approx_dy for more accuracy\n                x=np.linspace(-w_tot/2-1,w_tot/2+1,100),\n                y=np.linspace(-1.5,1.5,100)\n            )\n    c_mmi = mw.Cell(\n            structures=create_multimode(w=w_tot),\n            mesh=mesh,\n            z_min=0,\n            z_max=L,\n        )\n    c_launch = mw.Cell(\n            structures=create_io(w=io_width, offset=w_tot/2-io_width/4*3),\n            mesh=mesh,\n            z_min=0,\n            z_max=0,\n        )\n    \n    c_receive = mw.Cell(\n            structures=create_io(w=io_width, offset=w_tot/6-io_width/4*3),\n            mesh=mesh,\n            z_min=L,\n            z_max=L,\n        )\n\n    css = [mw.CrossSection(\n        cell=cell,\n        env=env,\n    ) for cell in [c_launch, c_mmi]]\n    \n    return css\n\n\ncss = construct_css(1e3)\n\n\nVerification\nLet’s check, whether everything looks as expected\n\nmw.vis(css[0])\n\n/home/jd/work/side/skill-challenge/.venv/lib/python3.10/site-packages/matplotlib/text.py:895: ComplexWarning: Casting complex values to real discards the imaginary part\n  y = float(self.convert_yunits(self._y))\n/home/jd/work/side/skill-challenge/.venv/lib/python3.10/site-packages/matplotlib/cbook.py:1345: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n/home/jd/work/side/skill-challenge/.venv/lib/python3.10/site-packages/matplotlib/text.py:754: ComplexWarning: Casting complex values to real discards the imaginary part\n  posy = float(self.convert_yunits(self._y))"
  },
  {
    "objectID": "mmi_briefing.html#mode-calculation",
    "href": "mmi_briefing.html#mode-calculation",
    "title": "Intoduction to MMIs",
    "section": "Mode Calculation",
    "text": "Mode Calculation\nLet’s calculate the modes supported by the multimode section and filter out the (q)TE modes:\n\nmodes = [cachedComputeModes(cs, num_modes=10) for cs in css]\nte_modes = [m for m in modes[1] if te_fraction(m)&gt;0.5]\n\n\nmw.vis(te_modes[:4])\n\n\n\n\nFrom the calculated refractive indices we can compute \\(L_\\pi\\), that is defined above\n\nk0 = 2*np.pi/env.wl\nl_pi = np.pi/(k0*te_modes[0].neff-k0*te_modes[1].neff)\nl_pi = np.real(l_pi)\n\nThe ideal length of an 2x2 MMI would thus be*:\n*Under the approximation, that the penetration depth of all TE modes is the same, and thus the \\(W_e\\) does not depend on the mode number \\(v\\). For high confinement waveguides this approximation introduces significant error, which necesitates additional means to find high performance device geometries. One such method is demonstrated in ‘How to optimize the transmission of an MMI’.\n\nl_pi*3/2\n\n4.126e+01"
  },
  {
    "objectID": "mmi_briefing.html#visual-inspection",
    "href": "mmi_briefing.html#visual-inspection",
    "title": "Intoduction to MMIs",
    "section": "Visual Inspection",
    "text": "Visual Inspection\nLet’s visualize the E-field while the excitation travels down the multimode waveguide. For this purpose we will use the propagate_modes functionality I introduced to meow. A more detailed description how MMIs can be described using meow is given in the notebook ‘How to propagate fields in meow’.\n\nfrom meow.eme.propagate import propagate_modes\nex_l = np.zeros(10)\nex_r = np.zeros(10)\nex_l[0] = 1\nex_l[1] = 1\n\nL = l_pi*3\nz = np.linspace(0,L,1000)\ny = 0.2\n\n\nE, x = propagate_modes(modes, ex_l, ex_r, y, z)\nX, Y = np.meshgrid(z, x)\nlim = np.quantile(np.abs(E), 0.98)\nplt.pcolormesh(X, Y, np.abs(E).T, shading=\"nearest\", vmin=0, vmax=lim)\nplt.axvline(L/2, color=\"w\")\n\n\n\n\nAs we can see the 2 images exist as hoped for. Note: It would be great to calculate the s-parameters now, however that requires ports in meow to work properly (see below) As an optimization of the transmission using FDTD is computationally expensive, a proof of concept using a 2D FDTD (tidy3D) is provided in ‘How to optimize the transmission of an MMI’."
  },
  {
    "objectID": "util.html",
    "href": "util.html",
    "title": "util",
    "section": "",
    "text": "These are just utility functions I use througout phoss. I mostly use this place for features that are not yet implemented in the respective open source packages I use.\n# util functions go here\nimport numpy as np\nimport gdsfactory.simulation.gtidy3d as gt\nimport matplotlib.pyplot as plt\nimport gdsfactory as gf\nfrom tqdm.notebook import tqdm\nimport meow as mw\n\ngf.config.rich_output()\nPDK = gf.generic_tech.get_generic_pdk()\nPDK.activate()\n\nnm = 1e-3\n\n2023-11-15 12:58:45.301 | INFO     | gdsfactory.config:__init__:205 - LogLevel: INFO\n2023-11-15 12:58:49.363 | INFO     | gdsfactory.simulation.gtidy3d:&lt;module&gt;:60 - Tidy3d '2.2.3' installed at ['/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/tidy3d']\nAt the time of setting these examples up TE_pol_fraction was not yet implemented by Tidy3D / gdsfactory. Now that it is implemented I should remove this and use the published version at some point.\ndef TE_pol_fraction(mode):\n        \"\"\"TE polarization fraction according to Lumericals definition. (assuming a regular mesh)\"\"\"\n        Ex_sq = np.abs(mode._data[\"Ex\"])**2\n        Ey_sq = np.abs(mode._data[\"Ey\"])**2\n        \n        return np.sum(Ex_sq, axis=(0,1))/np.sum(Ex_sq+Ey_sq, axis=(0,1))\n\nfrom meow.mode import Mode, eps0, mu0\n\ndef te_fraction(mode: Mode) -&gt; float:\n    \"\"\"the TE polarization fraction of the `Mode`\"\"\"\n    epsx = np.real(mode.cs.nx**2)\n    e = np.sum(0.5 * eps0 * epsx * np.abs(mode.Ex) ** 2)\n    h = np.sum(0.5 * mu0 * np.abs(mode.Hx) ** 2)\n    return np.real(e / (e + h))\nsource"
  },
  {
    "objectID": "util.html#caching-in-meow",
    "href": "util.html#caching-in-meow",
    "title": "util",
    "section": "Caching in meow",
    "text": "Caching in meow\nBy carefully caching modes we can avoid quite a lot of redundant calculations in meow. We need to be carefull however to not be sensitive with respect to parameters, that don’t influence the EM-mode, like z_min and z_max. The way I solve that here is pretty barebones. Since meow v0.7 this coupling is removed. So the workaround below should not be necessary anymore.\n\nclass cCrossSection(BaseModel):\n  cs: CrossSection = Field(\n    description=\"the contained CrossSection\"\n  )\n\n  def __hash__(self):\n    m = self.cs.cell.m_full\n    return dict_to_hash(dict(r=self.cs.cell.mesh.bend_radius, m=hash(m.tostring())))\n\n  def __eq__(self, other):\n    return hash(self) == hash(other)\n\nclass cMode(BaseModel):\n  mode: Mode = Field(\n    description=\"the contained Mode\"\n  )\n  \n  def getMode(self) -&gt; Mode:\n    return self.mode\n\n  def __hash__(self):\n    return dict_to_hash(dict(neff=str(self.mode.neff), r=str(self.mode.cs.cell.mesh.bend_radius)))\n  \n  def __eq__(self, other):\n    return hash(self) == hash(other)\n\n\nsource\n\ncMode\n\n cMode (mode:meow.mode.Mode)\n\nA customized pydantic base model that handles numpy array type hints\n\nsource\n\n\ncMode\n\n cMode (mode:meow.mode.Mode)\n\nA customized pydantic base model that handles numpy array type hints\n\nsource\n\n\ncCrossSection\n\n cCrossSection (cs:meow.cross_section.CrossSection)\n\nA customized pydantic base model that handles numpy array type hints\n\nsource\n\n\ncCrossSection\n\n cCrossSection (cs:meow.cross_section.CrossSection)\n\nA customized pydantic base model that handles numpy array type hints\n\n@cached\ndef inner(ccs, num_modes):\n  return mw.compute_modes(ccs.cs, num_modes)\n\ndef cachedComputeModes(cs, num_modes):\n  modes = inner(cCrossSection(cs=cs), num_modes)\n  return [mode.copy(update={'cs': cs}) for mode in modes]\n\n\nsource\n\n\ncachedComputeModes\n\n cachedComputeModes (cs, num_modes)\n\n\nsource\n\n\ncachedComputeModes\n\n cachedComputeModes (cs, num_modes)\n\n\nsource\n\n\ninner\n\n inner (ccs, num_modes)\n\n\nsource\n\n\ninner\n\n inner (ccs, num_modes)"
  }
]